package Playground

import org.scalacheck.{Arbitrary, Gen}
import org.scalacheck.Gen.{choose, frequency}

object Generators extends App {

  /*
  First function(
  myGen: Generator
  generatorIterations: Number of cycles you would like the generator to run
  )
  Second function(
  f: Function that operates on the value generated by the first function
   */
  def genericGenerator[A, B](myGen: Gen[A], generatorIterations: Int)(f: Option[A] => B): Any = {
    if (generatorIterations <= 1) f(myGen.sample)
    else {
      f(myGen.sample)
      genericGenerator(myGen, generatorIterations - 1)(f)
    }
  }

  //for-comprehension
  val myGenFor = for {
    n <- Gen.choose(10, 20)
    m <- Gen.choose(2 * n, 500)
  } yield (n, m)

  val forGenerator = genericGenerator(myGenFor, 1)(println)


  //zip - Creates a Tuple out of Generators
  val intGen = Gen.numChar
  val charGen = Gen.alphaChar
  val myGenZip = Gen.zip(intGen, charGen)

  val zipGen = genericGenerator(myGenZip, 1)(println)


  //result - Generates the result of some function
  val function = (x: Int, y: Int) => x * y
  val x = Arbitrary(Gen.oneOf(10, 20, 30))
  val y = Arbitrary(Gen.oneOf(2, 5, 9))

  val myGenResult = Gen.resultOf(function)(x, y)
  val resultGenerator = genericGenerator(myGenResult, 1)(println)


  //Negative Number
  val negativeNumber = Gen.negNum[Int]
  val negativeNumberPrint = genericGenerator(negativeNumber, 1)(println)


  //Tuple
  val stringsGen = for {
    alpha <- Gen.alphaStr
    num <- Gen.numStr
    id <- Gen.identifier
  } yield (alpha, num, id)

  val stringsGenPrint = genericGenerator(stringsGen, 1)(println)


  //frequency - control the rate at which data appears
  val evenNumberGen = for {
    n <- choose(2, 3)
  } yield 2 * n
  val oddNumberGen = for {
    n <- choose(0, 1)
  } yield 2 * n + 1
  val numberGen = frequency(
    (1, oddNumberGen),
    (2, evenNumberGen),
    (4, 0)
  )

  //
  //  var freqCheckList = List[Int]()
  //  def freqCheck(generatorIterations: Option[Int]): Unit = {
  //    val value = generatorIterations.get
  //    freqCheckList = value +: freqCheckList
  //  }
  //
  //  val numberGenPrint = genericGenerator(numberGen, 1)(println)
  //  val numberGenToList = genericGenerator(numberGen, 110)(freqCheck)
  //
  //
  //  def isEven(generatorIterations: Int): Boolean = generatorIterations % 2 == 0
  //  def isOdd(generatorIterations: Int): Boolean = generatorIterations % 2 != 0
  //
  //
  //  def numCheck(generatorIterations: Int): String = {
  //    if (generatorIterations ==0) "Zero"
  //    else if (isEven(generatorIterations)) "Even"
  //    else "Odd"
  //  }
  //
  //
  //  val reductionPrepList = freqCheckList.map(numCheck).groupBy(word => word).mapValues(_.size)
  //
  //  val testList = List(9,3,4)
  //  println(reductionPrepList)
  //  reductionPrepList.foreach(println)

  def myLengthFun(xs: List[Int]): Double = xs.foldLeft(1.0)((c: Double, x: Int) => x / c)
  //def myfold[A](xs: List[A]): Int = xs.foldLeft(0)((c,_) => c+2)

  val myLengthFunList = List(1, 2, 3, 4, 5)
  val myLengthFunList2 = List('1', '2', 'g', 'f', 'd')
  println(myLengthFun(myLengthFunList))
  //println(myLengthFun(myLengthFunList2))

}
